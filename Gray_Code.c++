//I have a solution here which takes O(1) on space and no recursion used. 

/*
In the Grey Code generated by (x>>1)^x, each bit is oscillating between going from off to on, 
and on to off. Meaning the pattern is 0,1,1,0 instead of 0,1,0,1 which is what you have for 
counting numbers. 0,1,1,0 should remind you of the XOR boolean table:
AB|A^B
00|0
01|1
10|1
11|0
Isolate any two adjacent bits in the counting sequence, and you will get the the table 
input repeating. We can come up with a formula for each bit b in the output g: g(b) = x(b) 
XOR x(b+1). Think of every next bit encoding whether the current bit is flipping on or flipping 
off. You can get all the bits at once with g = x ^ (x >> 1).
*/

/*
class Solution:
# @return a list of integers
def grayCode(self, n):
    num = 2**n
    return map(lambda x:(x>>1)^x,[x for x in range(num)])
*/

vector<int> grayCode(int n) 
{         
    vector<int> result(1, 0);        
    for (int i = 0; i < n; i++) {
        int curCount = result.size();
        // push back all element in result in reverse order
        while (curCount) {
            curCount--;
            int curNum = result[curCount];
            curNum += (1<<i);
            result.push_back(curNum);
        } 
    }
    return result;
}



public ArrayList<Integer> grayCode(int n) {
    ArrayList<Integer> arr = new ArrayList<Integer>();
    arr.add(0);
    for(int i=0;i<n;i++){
        int inc = 1<<i;
        for(int j=arr.size()-1;j>=0;j--){
            arr.add(arr.get(j)+inc);
        }
    }
    return arr;
}